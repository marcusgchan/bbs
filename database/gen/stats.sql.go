// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: stats.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const getMostRecentStats = `-- name: GetMostRecentStats :many
SELECT Avg.version, Avg.avgWave, Max.maxWave, Count.numOfTestEvents, StartDate.startDate, EndDate.endDate
    FROM (
    SELECT test_events.version, CAST(AVG(player_test_results.waveDied) AS REAL) as avgWave
    FROM (
        SELECT DISTINCT value as version FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    INNER JOIN test_results ON test_events.testResultId = test_results.id
    JOIN player_test_results ON test_events.testResultId = player_test_results.testresultId
    GROUP BY test_events.version
) as Avg, (
    SELECT test_events.version, CAST(MAX(player_test_results.waveDied) AS INTEGER) as maxWave
    FROM (
        SELECT DISTINCT value as version FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    INNER JOIN test_results ON test_events.testResultId = test_results.id
    JOIN player_test_results ON test_events.testResultId = player_test_results.testresultId
    GROUP BY test_events.version
) as Max, (
    SELECT test_events.version, COUNT(test_events.id) as numOfTestEvents
    FROM (
        SELECT DISTINCT value as version 
        FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    WHERE test_events.testResultId IS NOT NULL
    GROUP BY test_events.version
) as Count, (
    SELECT test_events.version, CAST(MIN(test_events.startedAt) AS TEXT) as startDate
    FROM (
        SELECT DISTINCT value as version FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    WHERE test_events.testResultId IS NOT NULL
    GROUP BY test_events.version
) as StartDate, (
    SELECT test_events.version, CAST(MAX(test_results.endedAt) AS TEXT) as endDate
    FROM (
        SELECT DISTINCT value as version FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    INNER JOIN test_results ON test_events.testResultId = test_results.id
    GROUP BY test_events.version
) as EndDate
WHERE Avg.version = Max.version
AND Max.version = Count.version 
AND Count.version = StartDate.version 
AND StartDate.version = EndDate.version
ORDER BY Avg.version DESC
`

type GetMostRecentStatsParams struct {
	Limit   int64
	Limit_2 int64
	Limit_3 int64
	Limit_4 int64
	Limit_5 int64
}

type GetMostRecentStatsRow struct {
	Version         string
	Avgwave         float64
	Maxwave         int64
	Numoftestevents int64
	Startdate       string
	Enddate         string
}

func (q *Queries) GetMostRecentStats(ctx context.Context, arg GetMostRecentStatsParams) ([]GetMostRecentStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostRecentStats,
		arg.Limit,
		arg.Limit_2,
		arg.Limit_3,
		arg.Limit_4,
		arg.Limit_5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostRecentStatsRow
	for rows.Next() {
		var i GetMostRecentStatsRow
		if err := rows.Scan(
			&i.Version,
			&i.Avgwave,
			&i.Maxwave,
			&i.Numoftestevents,
			&i.Startdate,
			&i.Enddate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByVersion = `-- name: GetStatsByVersion :one
SELECT Avg.version, Avg.avgWave, Max.maxWave, Count.numOfTestEvents, StartDate.startDate, EndDate.endDate
FROM (
    SELECT test_events.version, AVG(player_test_results.waveDied) as avgWave
    FROM test_events
    JOIN player_test_results ON player_test_results.testResultId = test_events.testResultId
    WHERE test_events.testResultId IS NOT NULL AND test_events.version = ?
) as Avg, (
    SELECT test_events.version, CAST(MAX(player_test_results.waveDied) AS INTEGER) as maxWave
    FROM test_events
    JOIN player_test_results ON player_test_results.testResultId = test_events.testResultId
    WHERE test_events.testResultId IS NOT NULL AND test_events.version = ?
) as Max, (
    SELECT test_events.version, COUNT(test_events.id) as numOfTestEvents
    FROM test_events
    WHERE test_events.testResultId IS NOT NULL AND test_events.version = ?
) as Count, (
    SELECT test_events.version, CAST(MIN(test_events.startedAt) AS DATETIME) as startDate
    FROM test_events
    WHERE test_events.testResultId IS NOT NULL AND test_events.version = ?
) as StartDate, (
    SELECT test_events.version, CAST(MAX(test_results.endedAt) AS DATETIME) as endDate
    FROM test_events
    JOIN test_results ON test_events.testResultId = test_results.id
    WHERE test_events.testResultId IS NOT NULL AND test_events.version = ?
) as EndDate
WHERE Avg.version = Max.version 
AND Max.version = Count.version
AND Count.version = StartDate.version
AND StartDate.version = EndDate.version
`

type GetStatsByVersionParams struct {
	Version   string
	Version_2 string
	Version_3 string
	Version_4 string
	Version_5 string
}

type GetStatsByVersionRow struct {
	Version         string
	Avgwave         sql.NullFloat64
	Maxwave         int64
	Numoftestevents int64
	Startdate       time.Time
	Enddate         time.Time
}

func (q *Queries) GetStatsByVersion(ctx context.Context, arg GetStatsByVersionParams) (GetStatsByVersionRow, error) {
	row := q.db.QueryRowContext(ctx, getStatsByVersion,
		arg.Version,
		arg.Version_2,
		arg.Version_3,
		arg.Version_4,
		arg.Version_5,
	)
	var i GetStatsByVersionRow
	err := row.Scan(
		&i.Version,
		&i.Avgwave,
		&i.Maxwave,
		&i.Numoftestevents,
		&i.Startdate,
		&i.Enddate,
	)
	return i, err
}
