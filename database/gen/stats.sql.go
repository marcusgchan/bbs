// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: stats.sql

package database

import (
	"context"
)

const getMostRecentStats = `-- name: GetMostRecentStats :many
SELECT AvgWave.version, AvgWave.avgWave, AvgMoney.avgMoneyEarned, MaxWave.maxWave, Count.numOfTestEvents, StartDate.startDate, EndDate.endDate
    FROM (
    SELECT test_events.version, CAST(AVG(player_test_results.wavesSurvived) as REAL) as avgWave
    FROM (
        SELECT DISTINCT value as version FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    INNER JOIN test_results ON test_events.testResultId = test_results.id
    JOIN player_test_results ON test_events.testResultId = player_test_results.testresultId
    GROUP BY test_events.version
) as AvgWave, (
    SELECT test_events.version, CAST(MAX(player_test_results.wavesSurvived) AS INTEGER) as maxWave
    FROM (
        SELECT DISTINCT value as version FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    INNER JOIN test_results ON test_events.testResultId = test_results.id
    JOIN player_test_results ON test_events.testResultId = player_test_results.testresultId
    GROUP BY test_events.version
) as MaxWave, (
    SELECT test_events.version, CAST(AVG(test_results.moneyEarned) as REAL) as avgMoneyEarned
    FROM (
        SELECT DISTINCT value as version 
        FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    INNER JOIN test_results ON test_events.testResultId = test_results.id
    GROUP BY test_events.version
) as AvgMoney, (
    SELECT test_events.version, COUNT(test_events.id) as numOfTestEvents
    FROM (
        SELECT DISTINCT value as version 
        FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    WHERE test_events.testResultId IS NOT NULL
    GROUP BY test_events.version
) as Count, (
    SELECT test_events.version, CAST(MIN(test_events.startedAt) AS TEXT) as startDate
    FROM (
        SELECT DISTINCT value as version FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    WHERE test_events.testResultId IS NOT NULL
    GROUP BY test_events.version
) as StartDate, (
    SELECT test_events.version, CAST(MAX(test_results.endedAt) AS TEXT) as endDate
    FROM (
        SELECT DISTINCT value as version FROM versions
        ORDER BY value DESC
        LIMIT ?
    ) as S
    JOIN test_events ON test_events.version = S.version
    INNER JOIN test_results ON test_events.testResultId = test_results.id
    GROUP BY test_events.version
) as EndDate
WHERE AvgWave.version = MaxWave.version
AND MaxWave.version = Count.version 
AND AvgMoney.version = Count.version
AND Count.version = StartDate.version 
AND StartDate.version = EndDate.version
ORDER BY AvgWave.version DESC
`

type GetMostRecentStatsParams struct {
	Limit   int64
	Limit_2 int64
	Limit_3 int64
	Limit_4 int64
	Limit_5 int64
	Limit_6 int64
}

type GetMostRecentStatsRow struct {
	Version         string
	Avgwave         float64
	Avgmoneyearned  float64
	Maxwave         int64
	Numoftestevents int64
	Startdate       string
	Enddate         string
}

func (q *Queries) GetMostRecentStats(ctx context.Context, arg GetMostRecentStatsParams) ([]GetMostRecentStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostRecentStats,
		arg.Limit,
		arg.Limit_2,
		arg.Limit_3,
		arg.Limit_4,
		arg.Limit_5,
		arg.Limit_6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostRecentStatsRow
	for rows.Next() {
		var i GetMostRecentStatsRow
		if err := rows.Scan(
			&i.Version,
			&i.Avgwave,
			&i.Avgmoneyearned,
			&i.Maxwave,
			&i.Numoftestevents,
			&i.Startdate,
			&i.Enddate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByVersion = `-- name: GetStatsByVersion :one
SELECT AvgWave.version, AvgWave.avgWave, AvgMoney.avgMoneyEarned, MaxWave.maxWave, Count.numOfTestEvents, StartDate.startDate, EndDate.endDate
FROM (
    SELECT test_events.version, CAST(AVG(player_test_results.wavesSurvived) as REAL) as avgWave
    FROM test_events
    INNER JOIN player_test_results ON player_test_results.testResultId = test_events.testResultId
    WHERE test_events.version = ?
) as AvgWave, (
    SELECT test_events.version, CAST(AVG(test_results.moneyEarned) as REAL) as avgMoneyEarned
    FROM test_events
    INNER JOIN test_results ON test_events.testResultId = test_results.id
    WHERE test_events.version = ?
) as AvgMoney, (
    SELECT test_events.version, CAST(MAX(player_test_results.wavesSurvived) AS INTEGER) as maxWave
    FROM test_events
    INNER JOIN player_test_results ON player_test_results.testResultId = test_events.testResultId
    WHERE test_events.version = ?
) as MaxWave, (
    SELECT test_events.version, COUNT(test_events.id) as numOfTestEvents
    FROM test_events
    WHERE test_events.testResultId IS NOT NULL AND test_events.version = ?
) as Count, (
    SELECT test_events.version, CAST(MIN(test_events.startedAt) AS TEXT) as startDate
    FROM test_events
    WHERE test_events.testResultId IS NOT NULL AND test_events.version = ?
) as StartDate, (
    SELECT test_events.version, CAST(MAX(test_results.endedAt) AS TEXT) as endDate
    FROM test_events
    INNER JOIN test_results ON test_events.testResultId = test_results.id
    WHERE test_events.version = ?
) as EndDate
WHERE AvgWave.version = MaxWave.version 
AND MaxWave.version = Count.version
AND AvgMoney.version = Count.version
AND Count.version = StartDate.version
AND StartDate.version = EndDate.version
`

type GetStatsByVersionParams struct {
	Version   string
	Version_2 string
	Version_3 string
	Version_4 string
	Version_5 string
	Version_6 string
}

type GetStatsByVersionRow struct {
	Version         string
	Avgwave         float64
	Avgmoneyearned  float64
	Maxwave         int64
	Numoftestevents int64
	Startdate       string
	Enddate         string
}

func (q *Queries) GetStatsByVersion(ctx context.Context, arg GetStatsByVersionParams) (GetStatsByVersionRow, error) {
	row := q.db.QueryRowContext(ctx, getStatsByVersion,
		arg.Version,
		arg.Version_2,
		arg.Version_3,
		arg.Version_4,
		arg.Version_5,
		arg.Version_6,
	)
	var i GetStatsByVersionRow
	err := row.Scan(
		&i.Version,
		&i.Avgwave,
		&i.Avgmoneyearned,
		&i.Maxwave,
		&i.Numoftestevents,
		&i.Startdate,
		&i.Enddate,
	)
	return i, err
}

const getVersions = `-- name: GetVersions :many
SELECT value, createdat FROM versions
`

func (q *Queries) GetVersions(ctx context.Context) ([]Version, error) {
	rows, err := q.db.QueryContext(ctx, getVersions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Version
	for rows.Next() {
		var i Version
		if err := rows.Scan(&i.Value, &i.Createdat); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
